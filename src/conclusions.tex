\chapter{Discussion}
\label{chap:conclusions}
This thesis has sought to answer the research question: how might one design and implement a Julia library to support programmatic experimentation with matroidal fair allocation algorithms? In an effort to answer this, I pursued several lines of inquiry. I implemented classic matroid operations, such as the matroid union and the exchange graph, and found practical ways to measure the fairness of a matroid-rank-valued allocation. I discussed the requirements of three recent algorithms in this space, later implementing these as a proof-of-concept. Lastly, I described how to represent and randomly generate matroids. With all this in hand, I gave an example of an experimental setup and provided some cursory results.

The primary goal of this thesis was to build Matroids.jl as an answer to that question---a practical tool to complement the theoretical toolkit provided by matroid theory. An important sub-goal was to figure out how to make Matroids.jl performant; as we have seen, matroids permit many powerful polynomial-time operations, such as the matroid union, that papers on matroidal fair allocation use in their analyses to show that allocations can be found efficiently. This obscures many implementation-level optimization decisions that can drastically improve the practical runtime of the implemented algorithms. One example of such an optimization is to use the rank function as sparingly as possible, in favor of cheaper independence or cardinality checks, as I discuss when giving some algorithm implementations in Chapter~\ref{chap:yankee-swap}.

\section{Limitations and future work}
The algorithms that were chosen for study (\pr{Envy-Induced-Transfers}, \pr{AlgMMS} and \pr{Yankee-Swap}), were chosen due their being relatively short and sweet, simple to reason about, and presenting a manageable amount of requirements to Matroids.jl. As we have seen, they are similar in spirit; all three produce clean, MAX-USW allocations, the first two starting with a matroid union call, the latter two using exchange graphs and transfer paths to modify the allocation. Consequently, Matroids.jl extracts this common logic into separate functions, to be optimized and reasoned about independently. A current limitation of Matroids.jl is that it is geared heavily towards supporting algorithms that follow this general structure---other hypothetical algorithms that take a completely different approach would likely require the implementation of other matroid operations.

Back in Chapter~\ref{chap:prelims}, I briefly mentioned matroidal constraints as the second major use case for matroids in the context of fair allocation. In order to maintain a manageable scope for this thesis, I elected to focus on matroid-rank valuations instead. For completeness' sake, a next step in the development of Matroids.jl should be to hook matroids into the constraint framework provided by Allocations.jl.

This thesis describes two ways of generating matroids: as graphic matroids, using different random graph models, or via the erection of arbitrary matroids. Table~\ref{tab:instances} shows the difference in performance when generating graphic matroids versus arbitrarily erected matroids of a similar size ($m=24$). Using graphic matroids, we could generate matroids of rank 13,14, and 21, hundreds of thousands of times faster than we were able to erect matroids of only rank 4,5, and 6. This might lead one to assume that graphic matroids are always preferable. To some extent this might be so, but a limitation of graphic matroids is that of representability. While every simple graph describes a matroid in terms of its acyclic subsets of edges, not every matroid can be expressed as a simple graph. Supplementary goods, for instance, would require a multigraph with two parallel edges. Little support exists in Julia for working with multigraphs at the moment. Further, matroids might be hypergraphs (graphs in which edges can connect more than two nodes) or might not lend themselves to a graphic representation at all. These are matroid qualities that are readily representable with our arbitrary erected matroids. Thus, we can see that there is a use for other matroid types as well, in addition to graphic matroids. In addition, different matroid types might have different properties that allow one to make different guarantees regarding fairness in a matroidal setting. As such, an important piece of future work on Matroids.jl is to add support for more types of matroids.
This thesis describes two ways of generating matroids: as graphic matroids, using different random graph models, or via the erection of arbitrary matroids. Table~\ref{tab:instances} shows the difference in performance when generating graphic matroids versus arbitrarily erected matroids of a similar size ($m=24$). Using graphic matroids, we could generate matroids of rank 13,14, and 21, hundreds of thousands of times faster than we were able to erect matroids of only rank 4,5, and 6. This might lead one to assume that graphic matroids are always preferable. To some extent this might be so, but a limitation of graphic matroids is that of representability. While every simple graph describes a matroid in terms of its acyclic subsets of edges, not every matroid can be expressed as a simple graph. Supplementary goods, for instance, would require a multigraph with two parallel edges. Little support exists in Julia for working with multigraphs at the moment. Further, matroids might be hypergraphs (graphs in which edges can connect more than two nodes) or might not lend themselves to a graphic representation at all. These are matroid qualities that are readily representable with our arbitrary erected matroids. Thus, we can see that there is a use for other matroid types as well, in addition to graphic matroids. Further, different matroid types might have different properties that allow one to make different guarantees regarding fairness in a matroidal setting. As such, an important piece of future work on Matroids.jl is to add support for more types of matroids.

There are numerous avenues available for improving the performance of Matroids.jl. One example is the exchange graph and related functionality. During a Yankee Swap run, the exchange graph is rebuilt, and the shortest paths recalculated from scratch, each iteration. This is likely a big performance drain, as most of the graph will not change between iterations, only the edges out of nodes corresponding to goods on the transfer path. One suggested performance improvement is to store the shortest path from every node to every other node on the exchange graph, though this might be a speed-memory usage tradeoff and should be considered carefully. Another interesting consideration is that of parallelization. I use multithreading in the matroid-rank-valued instance generator, given in Figure~\ref{code:gen_matroidrank_profile}, but it stands to reason that there might be room for parallelization within the matroid erection code, for instance. This could be a substantial source of performance improvement.

The matroid erection functionality, though significantly faster after the improvements outlined in Section~\ref{sec:improving-performance}, should preferably be made even faster. The latest implementation, whose performance is shown in Table~\ref{tab:perf_v5}, is a lot more memory efficient than earlier versions, but we can see that the runtime still explodes as $n$ grows. While it should be an interesting project to further optimize this implementation of Knuth's matroid construction, we might also consider whether this approach really scales any further with $n$. At the end of the day, the procedure considers in the worst case all subsets of $E$---as $n=|E|$ grows, the number of subsets of $E$ undergoes a combinatorial explosion, and quickly becomes intractably large. Any further improvements should begin to restrict which subsets the function looks at. We know, due to Greene~\cite{greene-1991}, that there exist families of closed sets, smaller than the full family of all closed sets of a matroid, that are descriptively sufficient (meaning they can be used to determine the properties of a matroid with simple and efficient algorithms). One such is the family of essential closed sets, i.e., the closed sets whose ``closedness'' do not follow from the closed sets of lower rank. These are roughly encoded by the enlargements passed to \pr{Knuth-Matroid}. Might it be possible to implement Knuth's matroid construction algorithm in such a manner as to only keep track of these essential closed sets? Would such an implementation be able to generate larger matroids, and faster, than the current implementation? These are interesting lines of questioning for future work into the matroid generation capabilities of Matroids.jl.

Another direction that one might take this work going forward, is to investigate the applicability of this product to real-world problems. Matroids are compelling structures to work with in the context of fair allocation, as they are pleasant to reason about and permit strong theoretical fairness guarantees. Unfortunately, people rarely think of their preferences in terms of matroids. The example given in Chapter~1 highlights that matroids do have real-world applicability in modelling user preferences, but design and engineering ingenuity would be needed to build a robust system that can reliably map between the two.

\section{Concluding remarks}
Initially, all I knew about this thesis was that it was going to have something to do with fair allocation. Looking around for recent allocation algorithms, the study of which might form part of a thesis, Viswanathan and Zick's Yankee Swap algorithm caught my attention. By restricting the valuations to the class of matroid rank functions, a seemingly simple algorithm could deliver extraordinarily well on a range of fairness objectives intractable in the general, additive case. My interest piqued, I wanted to understand how it worked, and set about implementing the algorithm using Hummel and Hetland's Allocations.jl library. Almost immediately I was flummoxed by how to represent the matroid rank valuations. I had assumed that there would exist some library to facilitate working programmatically with matroids, similar to how Graphs.jl enables working with graphs without needing to reinvent the wheel graph. At the time I was unable to find any such library, and so the research question for this thesis came to be: how might one design and implement a Julia library to support the implementation of and experimentation with matroidal fair allocation algorithms? 

Late in the project, I realized that there does in fact exist matroid libraries in Julia, in all likelihood vastly more performant and feature-rich than Matroids.jl would ever be\footnote{See for instance \href{https://docs.oscar-system.org/stable/Combinatorics/matroids/}{https://docs.oscar-system.org/stable/Combinatorics/matroids/}.}. The primary target demographic for Matroids.jl had always been fair allocation researchers, but upon witnessing the capabilities of my more advanced competitors, a secondary target demographic came to the fore, namely students, computer programmers and non-mathematicians such as myself. All along, I realized, I had been building the library for myself, the library that I had needed when I wanted to figure out how Yankee Swap worked, which was a simple-to-use matroid library that only concerned itself with the most basic aspects of matroids as they related to fair  allocation.

While matroid theory might seem an extremely abstract and niche subfield of mathematics, it has found applicability in the field of fair allocation, which in the end deals with problems of a highly practical and everyday nature. The aim of fair allocation, to deliver provably fair mechanisms for the distribution of resources, is a noble goal, and if a problem permits a matroidal representation, it can utilize algorithms that deliver very well indeed. If Matroids.jl is able to serve as a soft introduction to matroid theory for a computer programmer interested in understanding fair allocation algorithms, and if that computer programmer goes on to build a real-world solution for fair allocation, then Matroids.jl has achieved its goals as far as I am concerned.
