\chapter{Introduction}

Imagine you are a dean at a large university, responsible for allocating seats in courses to students for the coming semester. Each student has applied for some subset of the courses available, and each course has a limit on the number of students it can accept. In addition, there are scheduling conflicts between courses, and the students have hard limits on the number of courses they can take in a semester\footnote{This example is due to Benabbou et al~\cite{Benabbou_2020}.}. As a good dean, you wish to allocate fairly, ensuring that the students are happy with their courses and do not feel disfavored compared to the other students. At the same time, you strive for efficiency, so that every student gets enough courses to make the expected progress on their grade. How would you go about solving this problem? Over lunch, you discuss your quandary with a colleague from the computer science department who immediately assuages your fears by informing you that your situation is in fact an instance of indivisible fair allocation with matroid-rank valuations, a well-studied problem for which several algorithms exist! Eager to learn more, you ask your colleague to explain her cryptic remark.

\section*{What is fair allocation?}
Fair allocation is the problem of fairly partitioning a set of resources (in this case, the courses) among agents (the students) with different preferences or valuations over these resources. This has been a hot topic of interest since antiquity (a 2000-year old allocation strategy can be found in the Talmud~\cite{aumann-1985}), and remains so today. The mathematical study of fair allocation started with a seminal work by Steinhaus in 1948~\cite{steinhaus-1948}, and for decades the focus was largely on the \textit{divisible} case, in which the resources can be divided into arbitrary small pieces. In the divisible case, fair allocations always exist, and they can be computed efficiently~\cite{amanatidis2022fair}. In the dean's scenario, however, the course seats are \textit{indivisible goods}. A fair allocation of indivisible goods is, depending on the measure of fairness, not always achievable; consider for example allocating a course with one seat between two students who both applied for it -- there is no way of allocating the seat without one agent being unhappy.

Generally speaking, an allocation is measured against two justice criteria: \textit{fairness} and \textit{efficiency}. Fairness relates to the degree to which agents preceive the allocation as favoring other agents over themselves. One common way to describe the \textit{fairness} of an allocation is with the concept of \textit{envy-freeness}. Envy is defined as the degree to which an agent values another agent's received bundle of resources higher than their own. An allocation is envy-free if no agent envies another agent. In the trivial example above, the only envy-free allocation is the one in which no student receives the seat; while this is technically speaking fair, it is highly inefficient. Efficiency deals with maximizing some notion of resource utilization, or, equivalently, reducing waste. The perfectly fair allocation in which no one receives anything is rarely desirable for reasons of efficiency. Conversely, while the allocation in which one agent receives everything might be highly efficient in terms of the total sum of bundle values, it is obviously unfair. The task of the fair allocation algorithm, then, is to find some balance between these criteria.

\section*{How do matroids enter into this?}
What the colleague from the computer science department noticed about the dean's problem, was that it was well-structured, in fact it is a textbook example of \textit{matroid-rank valuations} in practice. Matroid rank functions (MRFs) are are a class of functions with properties that make them both easy to reason about and practically applicable in a setting such as fair allocation, and can equivalently be referred to as \textit{binary submodular functions}. A submodular function is a set function that obeys the law of \textit{diminishing returns} -- as the size of the input set increases, the marginal value of a single additional good decreases. MRFs are the class of submodular functions with \textit{binary marginals}, meaning that the value of any single good is either 0 or 1.

In practice, these properties make MRFs a compelling framework for modelling user preferences in a setting such as the dean's allocation scenario. The binary marginals reflect a student's willingness (value of 1) or unwillingness (value of 0) to enroll in a course. The diminishing returns property allow us to implement what are known in economics terms as \textit{supplementary goods} and \textit{fixed demand}. A student might be interested in two similar courses, but not wish to enroll in both, so given one, the marginal value of the other drops to 0 (the courses are supplementary goods). In addition, a student needs only at most one seat per course, so the many available seats for the same course are also supplementary goods. A student has limited time and energy, and so for each course seat received, the marginal value of the other courses can only decrease -- after some threshold is reached in the number of enrolled courses, all remaining courses have value 0 (there is a fixed demand for courses).

Matroids are extensively studied mathematical structures that generalize concepts from a variety of different fields. A number of interesting algorithms have been developed for fair allocation with matroid-rank valuations~\cite{barman2020fair,barman2021existence,Benabbou_2020,benabbou-2021,viswanathan2023yankee} that make use of deep results from matroid theory in their analysis, and deliver well on a range of justice criteria which might be computationally intractable to achieve under general valuations. 

\section*{What does this thesis contribute?}
Perhaps because matroids are so well-understood and pleasant to work with theoretically, there is a dearth of tooling available for generating and working with them programmatically. In an effort to complement the abundant theoretical toolkit provided by matroid theory, this thesis proposes Matroids.jl, a library for the Julia programming language~\cite{bezanson2017julia}, which extends the existing Allocations.jl library~\cite{Hetland_Allocations_jl_2022} with the functionality required to enable the empirical study of matroidal fair allocation algorithms. 

In this work, my primary contribution is the design and implementation of Matroids.jl as a practical tool that introduces new capabilities for handling matroids in the context of fair allocation. This thesis details the practical considerations that went into the development of the library, with code excerpts scattered throughout\footnote{The full source code can be found at \href{https://github.com/aaaeide/Matroids.jl}{https://github.com/aaaeide/Matroids.jl}}. In addition, I present some experimental results obtained by implementing three select algorithms. While these results might present somewhat novel insights, I feel the need to underscore that they are given mainly as illustrative examples of Matroids.jl's utility and are not the central focus of this thesis. 

This thesis describes the work that has been done to design and build a working, proof-of-concept version of Matroids.jl. It is structured as follows. In the next chapter, I establish the concepts from matroid theory and fair allocation necessary to understand the rest of the thesis. In Chapter~\ref{chap:matroids.jl}, I describe the design and implementation of the Matroids.jl API, which includes various classic matroid algorithms that have found use in fair allocation algorithms. In Chapter~\ref{chap:yankee-swap}, I show how this API can be used to implement Viswanathan and Zick's Yankee Swap algorithm~\cite{viswanathan2023yankee} and some other algorithms for matroid-rank-valued fair allocation. In Chapter~\ref{chap:generating_matroids}, I show how Matroids.jl implements the random generation of a range of matroid types. Of particular interest here is Knuth's classic method for generating arbitrary matroids~\cite{knuth-1975}, the successful implementation of which was a significant sub-goal of the project. In Chapter~\ref{chap:results}, I provide some experimental results for the algorithms over different matroid types. Finally, in Chapter~\ref{chap:conclusions}, I give a summary discussion on the limitations of Matroids.jl and suggests a few possible avenues of future work.

