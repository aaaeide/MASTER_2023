\chapter{The Matroids.jl API}
In the previous chapter, I described how our library generates and represents matroids, as well as how to access the basic properties of our matroids. If all one wanted was to play around with matroids in and of themselves, one might have declared the library finished at this point. However, as mentioned in the introduction, the raison d'Ãªtre of Matroids.jl is to enable the empirical study of fair allocation algorithms that utilize matroids in some capacity. In this chapter, I consider what fair allocation-specific methods the Matroids.jl API should expose to achieve this goal, and how they might be implemented. The implementation will draw inspiration from, and be designed to interoperate with, Hummel and Hetland's well-organized Allocations.jl library~\cite{Hetland_Allocations_jl_2022}. 

We will have fair allocation's two main use cases for matroids in mind when deciding what the Matroids.jl API should look like: matroidal rank valuations and matroidal constraints. This chapter will consist of a literature study, the goal of which is to understand what functionality algorithms for these cases will require, after which I discuss the implementation in Matroids.jl. In the next chapter, I will as a proof of concept describe an implementation of the Yankee Swap algorithm for fair allocation with matroidal valuations~\cite{viswanathan2023yankee} that make use of the functionality developed in this section, and present some experimental results. Before all this though, we should establish the required fair allocation concepts.
